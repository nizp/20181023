<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
<style>
div{
    padding:100px;
}
#box1{
    background: red;
    position: relative;
   
}
#box2{
    background: yellow;
    border: 10px solid #000;
}
#box3{
    background: green;
    position: absolute;
    border: 10px solid #000;
}

</style>
</head>
<body>
    <div id="box1">
        <div id="box2">
            <div id="box3"></div>
        </div>
    </div>
<script>
    /*
        offsetLeft:
            子元素的左外边框到定位父级的左内边框的距离

        offsetTop:
            子元素的上外边框到定位父级的上内边框的距离

        offsetParent   定位父级

        clientLeft/clientTop
            元素的左边框/元素的上边框


        如果子级没有定位，默认走body


        思路:
            先计算当前元素的定位距离和边框，当前元素有定位父级，再计算（包括边框），定位父级的
            定位距离，一直到没有定位父级，就不计算了，最后减去目标元素的左边框。


        ele.getBoundingClientRect() -> 返回值为对象

            有 x,y,width,height,top,left,right,bottom;

            注意：
                获取的值，会随着浏览器的变化来变，比如获取top值，如果有滚动条
                那么这个值就会发生变化。

                它是一直以浏览器可视区为依据，来计算元素到当前可视区的位置

    */
    // console.log(box3.offsetParent);

    /*
        100 + 10

    */
    let ele = box3;
    let l = 0;
    let box3L = box3.clientLeft;
    while(ele){ //只要有元素就进循环
        l += (ele.offsetLeft + ele.clientLeft);
        ele = ele.offsetParent;
    }
    l -= box3L;
    // console.log(l);
    // console.log(box3.clientLeft);

    console.log(box3.getBoundingClientRect());

    // console.log(getComputedStyle(box3).borderLeftWidth);

</script>
</body>
</html>